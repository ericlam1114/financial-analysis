// Placeholder for src/lib/exportUtils.js\n// Contains logic for generating Excel and Markdown files\n\nimport ExcelJS from 'exceljs'; // Import when needed for Excel export\n\n/**\n * Generates an Excel file (XLSX) representing the valuation.\n * @param {object} data - Data needed for the export.\n * @param {Array<object>} data.messages - Chat history.\n * @param {Array<object>} data.retrievedRows - Rows retrieved during RAG.\n * @param {object} data.functionCall - The function call details (name, args).\n * @param {any} data.functionResult - The result of the function call.\n * @returns {Promise<Blob>} - A Blob representing the XLSX file.\n */\nexport async function generateExcelExport({ messages, retrievedRows, functionCall, functionResult }) {\n  console.log(\"Generating Excel export with data:\", { messages, retrievedRows, functionCall, functionResult });\n\n  const workbook = new ExcelJS.Workbook();\n  workbook.creator = 'Valuations AI';\n  workbook.created = new Date();\n\n  // --- Summary Sheet ---\n  const summarySheet = workbook.addWorksheet('Summary');\n  summarySheet.columns = [\n    { header: 'Metric', key: 'metric', width: 25 },\n    { header: 'Value', key: 'value', width: 50 },\n  ];\n\n  summarySheet.addRow({ metric: 'Valuation Status', value: 'Placeholder - Needs Implementation' });\n  if (functionCall) {\n      summarySheet.addRow({ metric: 'Function Called', value: functionCall.name });\n      // TODO: Nicely format arguments\n      summarySheet.addRow({ metric: 'Arguments', value: JSON.stringify(functionCall.arguments) });\n  }\n   if (functionResult !== null && functionResult !== undefined) {\n       // TODO: Nicely format result (e.g., currency for DCF/NPV)\n       summarySheet.addRow({ metric: 'Result', value: JSON.stringify(functionResult) });\n   }\n  // TODO: Add Cash Flow Summary if applicable (from functionResult?)\n\n  // --- Trace Sheet ---\n  const traceSheet = workbook.addWorksheet('Trace');\n   traceSheet.columns = [\n      { header: 'Source Content', key: 'content', width: 80 },\n      { header: 'File', key: 'file', width: 30 },\n      // Add other relevant metadata keys as columns\n  ];\n  traceSheet.addRows(retrievedRows.map(row => ({\n      content: row.pageContent,\n      file: row.metadata?.source || 'N/A',\n      // ...other metadata fields\n  })));\n\n   // --- Chat History Sheet ---\n   const chatSheet = workbook.addWorksheet('Chat History');\n   chatSheet.columns = [\n      { header: 'Role', key: 'role', width: 15 },\n      { header: 'Message', key: 'message', width: 100 },\n   ];\n   chatSheet.addRows(messages.map(msg => ({\n       role: msg.role,\n       message: msg.content\n   })));\n\n  // Apply basic formatting (optional)\n  [summarySheet, traceSheet, chatSheet].forEach(sheet => {\n      sheet.getRow(1).font = { bold: true };\n  });\n\n  // Generate buffer and return as Blob\n  const buffer = await workbook.xlsx.writeBuffer();\n  return new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });\n}\n\n/**\n * Generates a Markdown file (.md) representing the valuation memo.\n * @param {object} data - Data needed for the export.\n * @param {Array<object>} data.messages - Chat history.\n * @param {Array<object>} data.retrievedRows - Rows retrieved during RAG.\n * @param {object} data.functionCall - The function call details (name, args).\n * @param {any} data.functionResult - The result of the function call.\n * @returns {Promise<Blob>} - A Blob representing the Markdown file.\n */\nexport async function generateMarkdownExport({ messages, retrievedRows, functionCall, functionResult }) {\n  console.log(\"Generating Markdown export with data:\", { messages, retrievedRows, functionCall, functionResult });\n\n  let mdContent = `# Valuation Memo\n\n## Summary\n\nThis memo summarizes the AI-driven valuation analysis performed on ${new Date().toLocaleDateString()}.\n\n`;\n\n if (functionCall) {\n      mdContent += `## Calculation Performed\n\n**Function:** \`${functionCall.name}\`\n\n**Arguments:**\n\`\`\`json\n${JSON.stringify(functionCall.arguments || {}, null, 2)}\n\`\`\`\n\n`;\n  }\n\n  if (functionResult !== null && functionResult !== undefined) {\n      mdContent += `**Result:**\n\`\`\`json\n${JSON.stringify(functionResult, null, 2)}\n\`\`\`\n\n`;\n  }\n\n  mdContent += `## Context Used (${retrievedRows.length} rows)\n\n`;\n  if (retrievedRows.length > 0) {\n      retrievedRows.forEach((row, i) => {\n          mdContent += `${i + 1}. ${row.pageContent || JSON.stringify(row)}\n`;\n          if(row.metadata?.source) mdContent += `   *Source: ${row.metadata.source}*\n`;\n          mdContent += `\n`; // Add a newline for spacing\n      });\n  } else {\n      mdContent += `*No specific context rows were retrieved for this query.*\n\n`;\n  }\n\n\n  mdContent += `## Chat History\n\n`;\n  messages.forEach(msg => {\n      mdContent += `**${msg.role === 'user' ? 'User' : 'Assistant'}:**\n${msg.content}\n\n`;\n  });\n\n  return new Blob([mdContent], { type: 'text/markdown;charset=utf-8' });\n}\n 